Task: Introduce nested “Step/Block” execution with always-copy semantics and a single merge pointGoalYou’re evolving from a flat, linear list of prompt steps to a structure that can express:“Run a generic refinement loop after most stages” (your old tot_enclave pattern)future mini-pipelines: tool chains, agentic subroutines, evaluators, retries, etc.programmatic experimentation: enable/disable refinement, apply it to only some stages, override temperatures/params per stage…while staying intuitive to read and avoiding “two places main can be modified.”Core principle:> A parent conversation is never mutated during execution.Every node runs against a working copy, and the only time the parent changes is during a single “merge” step at the end of that node.This restores the original intention behind messages_main vs messages_log, except “logging” is now the transcript recorder (JSON), not a second conversation.Non-goalsDo not redesign prompt content.Do not implement multi-agent enclaves yet.Do not add a DB, UI, or service.Do not add complex “query language” selectors (no where=lambda ... in end-user pipeline definitions).Do not allow silent behavior changes: if a merge mode is invalid, a selector references a missing step, etc., raise.---Definitions (keep these clear in code + docs)StepA single unit of work. For v1, this is “one LLM chat call” (your current ChatStep semantics).BlockA named group of nodes (steps or other blocks). A block exists to:express nesting visiblycontrol what (if anything) is merged back to its parent conversationMerge mode (what persists back to the parent conversation)A block has a merge policy determining what changes the parent conversation sees after the block runs:merge="all_messages"Parent receives all messages produced by the block (user prompts + assistant responses that actually ran inside the block, including nested merges).merge="last_response"Parent receives only the final assistant response produced by the block.merge="none"Parent conversation is unchanged.Important: merge applies only to conversation state. It does not magically undo tool side effects (future tool steps).---Functional requirementsFR1 — Node model supports arbitrary nestingDefine Node = Step | Block.A Block can contain any list of nodes (Steps or Blocks), arbitrarily deep.FR2 — Always-copy execution (single mutation point)For every node execution:Create a working copy of the parent conversation.Run the node against the working copy.Compute the “produced messages” delta.Apply the block’s merge policy to the parent conversation in exactly one place.No other code path may append to the parent conversation.This is the invariant that eliminates the “two places it can be modified” confusion.FR3 — Step execution must not leave dangling messages on failureWithin a step:Do not append the user prompt into the working conversation until you know the model call succeeded.In practice:build a temporary message list = working + user promptcall text_chat(...)validate responseonly then append (user prompt + assistant response) to the working conversationThis prevents “half-applied” steps.FR4 — Transcript records everything, independent of mergeEven if a block uses merge="none", all internal steps must still be recorded to the transcript (your ctx.steps list) with:prompt textresponse textparams usedtimestampspath (see FR5)Merge only governs what persists in conversation. Logging is always complete.FR5 — Nested path recorded for every stepBecause enclave steps will be reused repeatedly (and names will repeat), each step record must include a path so it’s uniquely identifiable.Minimum:path: string like "pipeline/section_2_choice/tot_enclave/enclave_consensus"name: the step’s local label (optional)Keep existing fields: prompt, response, params, created_at, etc.FR6 — Names optional, but never ambiguousTo keep authoring simple, allow omitting names—but do it in a way that avoids confusion.Requirements:Step.name and Block.name may be optional.If a name is missing, generate a deterministic fallback for that node within its parent, based on index:e.g., "step_01", "block_02"If explicit sibling names collide within the same block, raise (don’t silently disambiguate).Transcript path must use the effective/generated names so the run is self-describing.Guidance for authors (document this):Use explicit names for major stages you want to target in experiments.Generated names are fine for “internal plumbing” steps.FR7 — Merge mode validation is strictBlock.merge must be one of the allowed values.If merge="last_response" and the block produces no assistant responses (empty block, or block with only merge-none children), raise ValueError (“last_response requested but no assistant output exists”).FR8 — Error attribution includes the step pathWhen an exception occurs during plan execution, attach:pipeline_path (the full path to the failing node)(optionally) pipeline_node_namerun_generation() should include that path in ctx.error.step (or ctx.error.path).This prevents “which enclave consensus failed?” confusion.FR9 — Backwards-compatible wrapper for flat pipelinesTo avoid breaking everything at once:Keep an API that accepts a flat list of Steps (like today), but internally:wrap it in a root Block with merge="all_messages"execute via the new node runnerThis is a migration convenience; update the canonical code path to use Blocks once it’s working.---Implementation instructions (agent-facing)Step 0 — Locate canonical entry pointsFind:the current runner (ChatRunner) and step type (ChatStep) in pipeline.pythe generation entry point (likely run_generation() in the refactored path; if there are multiple mains, pick one canonical path and update docs to reflect it)transcript writer (write_transcript)The work is primarily in pipeline.py plus updating whichever main path actually uses it.Step 1 — Introduce Block and Node typesAdd in pipeline.py:@dataclass(frozen=True) class Block:name: str | None = Nonenodes: list[Node]merge: Literal["all_messages","last_response","none"] = "all_messages"capture_key: str | None = None (captures the block’s final assistant output)Define:Node = ChatStep | Block (or rename ChatStep to Step; keep alias for minimal churn)Step 2 — Add deterministic name/path computationImplement a helper that, given:parent path segments (list[str])nodeindex within parentreturns:effective_name: str (either node.name or generated fallback)child_path: list[str] (parent + effective_name)Enforce:within each Block.nodes, all explicit names are unique; else raise.Step 3 — Implement “execute node on copy, then merge” engineAdd a new method on ChatRunner:run(ctx: RunContext, node: Node) -> NoneExecutes node against a copy of ctx.messages, then merges into ctx.messages according to the root node’s merge.Internally implement:_execute_node(ctx, node, parent_messages: MessageHandler, path: list[str]) -> tuple[list[dict], str | None]Where return values are:produced_messages: the full delta (messages the node created in its working copy)last_assistant: last assistant response text produced inside the node (after nested merges)Step execution_execute_step(...) should:render prompt (fail-fast rules unchanged)call model using messages_for_call = parent_messages.messages + [user_msg] (don’t mutate)validate response (fail-fast rules unchanged)

produce produced_messages = [user_msg, assistant_msg]

append transcript record with path="/".join(path + [effective_step_name])return produced_messages and last_assistant=responseBlock execution_execute_block(...) should:

validate merge modecreate working = parent_messages.copy() (the working copy)for each child:

execute child against working as parent, but because children must not mutate their parent directly:execute child on a copy of working and return child_produced + child_last_assistantapply ch
ild merge policy to wo
rking in one place:if child is a Step: treat as merge all_messages into working (steps are message-producing)if child is a Block: apply its merge mode (all_messages / last_response / none)

at end:
compute block_produced = working.messages[len(parent_messages.messages):]compute block_last_assistant = last assistant message that actually exists in working delta

if block.merge is evaluated by the parent, do not apply it here (block itself doesn’t mutate its parent)

if block.capture_key: store block_last_assistant in ctx.outputs[capture_key] (even if merge=none; document this)
return block_produced and block_last_assistantStep 4 — Merge application rules (single place)


Implement a helper:
_apply_merge(parent_working: MessageHandler, merge_mode: str, produced_messages: list[dict], last_assistant: str | None) -> NoneRules:all_messages: extend parent_working with produced_messageslast_response: append one assistant message with content=last_assistant (raise if None/empty)

none: do nothing

Do not allow any other path to modi

fy parent_working.This is the core invariant.Step 5 — Update transcript structure

In pipeline.py, step records currently include "name": step.name. Extend each record with:
"path": "/".join(path_segments)
(optional) "local_name": step.name (if you want both)Update transcript.py only if needed (it already writes ctx.steps).Step 6 — Update failu
re attribution
When catching exceptions during node execution:attach pipeline_path attribute to the exception (full path string)optionally attach pipeline_node_type (“step”/“block”)Then, in the outer error handler of run_generation() (or equivalent), include that path in ctx.error.Step 7 — Reintroduce ToT/enclave as a reusable block (example integration)Add a helper in your main pipeline construction code:
Define tot_enclave_block = Block(name="tot_enclave", merge="all_messages", nodes=[Step("enclave_opinion"...), Step("enclav
e_consensus"...)] )
Then apply it after most stages by wrapping each stage into its own block:
stage_block = Block(name=stage_name, merge="last_response", nodes=[stage_step, tot_enclave_block], capture_key=... )
Create a root block with merge all_messages:
root = Block(name="pipeline", merge="all_messages", nodes=[stage_block1, stage_block2, ...])This yields the intended behavior:each stage runs its internal prompt + refinement loop in a working copy
only the final refined output is merged up to the parenttranscript still contains full detail
Step 8 — Keep a simple flat-list API for transitionIf existing code still calls runner.run_steps(ctx, steps):
implement it as a wrapper that builds Block(nodes=steps, merge="all_messages") and calls run(ctx, block).
---Testing requirements (pytest, offline, no network)Add unit tests that verify the invariants. These tests should not depend on prompt wording.Unit tests: merge semantics1. merge=none leaves parent unchangedParent messages start with 1 system message.Block contains two steps that would produce output.Execute block with merge="none" inside a parent block that merges all.Assert: parent conversation unchanged.Assert: transcript recorded those steps.2. merge=last_response appends exactly one assistant messageBuild a block with two internal steps:step1 returns "A"step2 returns "B"Execute with merge=last_response into parent.Assert: parent gains exactly one assistant message with "B".3. merge=all_messages includes user+assistant pairsExecute a simple block with 1 step.Assert: parent includes the user prompt message and assistant response.4. merge=last_response raises if no assistant outputEmpty block with merge=last_response → raises.Or block whose children are blocks with merge=none (so nothing persists) → raises if last_response requested.Unit tests: nested path uniqueness5. Repeated enclave step names don’t collideUse the same tot block under two different stage blocks.Assert transcript step paths are distinct (different prefixes).Unit tests: dangling-message prevention6. If model raises, parent is unchangedFakeTextAI raises on a step.Assert parent conversation is unchanged (no partial prompt appended).Assert transcript includes steps before failure only.Integration test: ToT wrapping reduces persisted context7. Run a small pipeline where each stage is wrapped with tot, merge=last_responseEnsure the final parent conversation contains only one assistant message per stage block (plus system), not the full internal history.Ensure transcript still contains internal steps for each stage.---Documentation updates (must add)Update README or add docs/pipeline.md with:1. ConceptsStep: one model callBlock: group of steps/blocksMerge: what persists to parent conversationTranscript: always records full detail; not part of model context2. Merge modes explained with a tiny example Show:merge all_messages vs last_response vs none3. How to express ToT/enclave Show the exact “stage block = [stage step + tot block], merge last_response” pattern.4. Guidance on namingnames optionalgenerated names appear in transcriptuse explicit names for major stages you want to target in experiments---Acceptance criteria (Definition of Done)You can represent pipelines as nested Steps/Blocks with arbitrary depth.Parent conversation state is mutated only by merge (single place); no partial/dangling messages appear on failure.merge="none"|"last_response"|"all_messages" behave exactly as specified and are covered by tests.Transcript JSON contains full step history with unique path fields even when substeps repeat across stages.eintrdcin oTs clait’just a reabl Block isedafter motstags, and thpersistdcontext says sal.Tets s ofline uderpytet nd do nc pom stns--Ptfalls  avdo ot eat tansriptloggingas a “coveration.” oging ecorder; the mde shol never reat.Do notalow “mrge lastresponse” o siletly  nothg. f heres  lasrponse raie.Donot mutate aet mesages insdestep xuton. Aly build tempsge forthe model cal, thenmergon.o nt reinoucpredctlambd (werlambd ..) itoppel definitions Use xlic lsts/lockkept edable.f you ant the agnt tkepchages ultminial: p Chat as-is ad Block d ChtRuer.run(ctx, nde,and kep run_stepsa rappe. Then pdae the anonica pipelin onstrctonto us thened locks fo ToT.









































































































































































































































































































































































































































































































































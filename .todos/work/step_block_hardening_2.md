Task: Pipeline hardening + clarity pass (strict config booleans, cross‑platform upscaler test, clearer paths/logs, remove legacy ambiguity)## GoalDeliver a small set of changes that measurably reduce “surprising behavior” and make the pipeline easier to modify during iterative experimentation, without redesigning prompts or introducing new architectural layers.This task targets:1. **No silent misconfiguration:** `enabled: "false"` must never behave as true.2. **Cross-platform tests:** the upscaling integration test must not accidentally be Windows-only.3. **Clarity for readers:** operational logs should show *which exact nested step* ran; transcript paths should not look duplicated/confusing.4. **No silent fallbacks (fonts):** if the user explicitly configures a caption font path and it can’t be loaded, fail loudly (or at minimum, warn loudly and be consistent).5. **Reduce confusion in main module:** keep the canonical path obvious; isolate or remove legacy helpers that are no longer used.6. **Remove “two ways to set temperature” ambiguity** so parameter sweeps don’t behave unexpectedly.## Non-goals* Do not change prompt wording/content except as needed for tests.* Do not change the fundamental Step/Block/merge semantics.* Do not implement new agent types, tool steps, branching, retries, evaluators, etc.* Do not add new runtime dependencies.* Do not change output formats (manifest/transcript schema) other than adding clarity fields (e.g., path in logs).---# Functional requirements## FR1 — Strict boolean parsing in config (no `bool("false")` footguns)### RequirementWherever config currently does `bool(cfg.get("enabled"))`, replace with strict parsing:* Accept:  * `True` / `False`  * `0` / `1` (ints)  * strings (case-insensitive) `"true"`, `"false"`, `"1"`, `"0"`, optionally `"yes"`, `"no"`* Reject everything else by raising `ValueError` with an explicit key path (e.g., `Invalid boolean for rclone.enabled: "maybe"`)### Applies to at minimum* `rclone.enabled`* `upscale.enabled`* any other `*.enabled` flags you have### No silent fallbackIf the value is present but invalid → raise.If missing → default is allowed (as defined today), but document it.---## FR2 — Upscaling integration test must be cross-platform### RequirementThe integration test for upscaling must work on:* Linux/macOS (POSIX)* Windows### BehaviorThe test should create a **fake upscaler executable** that mimics the CLI your upscaling wrapper calls, including writing an output file, so the pipeline believes it succeeded.The test must not depend on `.cmd` being executable on POSIX.### Implementation approach (recommended)In the test:* If Windows:  * create a `.cmd` wrapper that calls a python script* If POSIX:  * create a small `#!/usr/bin/env python3` script and `chmod +x` it (or call `sys.executable` explicitly)The script should:* parse the relevant args your wrapper passes (you don’t need a perfect parser—just enough to find the output path)* write a valid image file to the expected output path### No silent fallbackIf the fake binary cannot execute, the test should fail with a clear assertion (not “passed but skipped behavior”).---## FR3 — Operational logs must show full nested pipeline path### RequirementWhenever a step runs, the INFO log line must include the full unique path, not just the local step name (which repeats in nested blocks).Example desired INFO lines:* `Step: pipeline/section_2_choice/draft`* `Step: pipeline/section_2_choice/tot_enclave/enclave_consensus`This should happen in the pipeline runner layer so it applies everywhere.---## FR4 — Caption font path: explicit config must not silently fall back### RequirementIf `caption_font_path` (or the equivalent config field) is **explicitly set** and the font cannot be loaded:Pick one consistent behavior:* **Preferred:** raise `ValueError` (fail-fast) with the path and underlying exception* **Acceptable alternative:** log a WARNING that includes the path and the exception, then fall backDo not silently ignore the user’s explicit font path.If no font path is provided, “best-effort fallback” is fine.---## FR5 — Transcript paths should avoid “duplicate name” confusion### RequirementAvoid paths like:* `pipeline/section_2_choice/section_2_choice`They’re technically correct but confusing.### Minimal changeWhen building the per-stage wrapper block, keep the block name as the stage name, but name the inner “stage step” something stable like `"draft"`.So:* `pipeline/section_2_choice/draft`* plus ToT: `pipeline/section_2_choice/tot_enclave/enclave_consensus`This improves readability without changing semantics.---## FR6 — Temperature should not be set in two places### ProblemIf both `step.temperature` and `step.params["temperature"]` exist, precedence becomes confusing during sweeps.### RequirementChoose one canonical source of truth and enforce it.**Recommended minimal policy:*** `ChatStep.temperature` is authoritative* `step.params` must NOT contain `"temperature"`* If it does, raise `ValueError` at step validation timeThis is the least surprising model for mixed-experience readers (“temperature is a field”), and it prevents subtle overrides.Document this clearly.---## FR7 — Legacy helpers should not live in the canonical module### RequirementIf old helpers like `message_with_log()` / old `tot_enclave()` are no longer used by the canonical pipeline:* Move them into `legacy_main.py` (or `legacy/` module), OR* Delete them if truly unusedThe canonical `main.py` should contain only the modern implementation path (or clearly separate “legacy path” with a big header comment and no name collisions).This reduces mis-edits by future contributors/agents.---# Implementation instructions (agent-facing)## Step 0 — Identify the canonical code pathLocate:* the entry point used in real runs (likely `run_generation(...)` / new `main()`).* confirm which module builds the pipeline tree (Steps + Blocks).Do not update legacy paths unless required to keep the repo importable.---## Step 1 — Implement strict boolean parsing in `run_config.py`Add helpers:* `parse_bool(value: Any, path: str) -> bool`* `optional_bool(cfg: dict, key_path: str, default: bool) -> bool` (optional convenience)Update config parsing to call these for any enabled flags.Add unit tests:* `"false"` → False* `"true"` → True* `"0"` → False* `"1"` → True* invalid string → raises ValueError with the key pathPitfall to avoid:* Do not treat arbitrary non-empty strings as True.* Do not silently accept `None` where a bool is required (either default or raise, but make it explicit).---## Step 2 — Fix upscaling integration test portabilityLocate the upscaling integration test file (likely `tests/test_upscaling_integration.py` or similar).Modify the fake binary creation:### POSIX path* Write a python script with a shebang.* `chmod +x` the script.* Make the upscaling config point to that executable script path.### Windows path* Keep the `.cmd` wrapper or generate a `.bat` / `.cmd` that calls python.The fake tool should:* accept whatever args your wrapper passes (minimum: it must be able to find an output file path)* write an output image that PIL can open (use PIL to write a tiny image in the fake tool if easiest)Pitfalls to avoid:* Don’t assume `.cmd` runs on Linux.* Don’t write a “fake” that exits 0 but doesn’t create output; that produces misleading green tests.---## Step 3 — Log full pipeline path for each stepIn the pipeline runner:* locate where step execution logs occur* change the log line to include the full computed path (the same string you store in transcript records)If you don’t currently have the path at that point, pass it down explicitly (prefer explicit parameters over recomputation).Optional test:* capture logs with pytest `caplog` and assert the path appears.Pitfall:* Don’t log only local step names; nested repeats will make logs unusable.---## Step 4 — Enforce font path behavior in image captioning utilityLocate the font loading function (where the provided `caption_font_path` is used).Implement:* If `font_path is not None` and loading fails:  * raise `ValueError` (preferred) OR warn loudly and fallback (choose one and implement consistently)Add tests:* Provide an invalid font path and assert:  * exception raised (preferred), OR  * warning logged and fallback occurs (if you choose warning)Pitfall:* Don’t swallow the exception silently.* Don’t change behavior for “no font path provided” (best-effort fallback is fine).---## Step 5 — Rename inner stage step to `draft` to improve transcript readabilityWherever you build “stage blocks” like:* `Block(name=stage_name, nodes=[Step(name=stage_name, ...), tot_block])`Change to:* `Block(name=stage_name, nodes=[Step(name="draft", ...), tot_block])`Ensure:* no sibling collisions inside the stage block (there shouldn’t be)* any code that targets the stage step by name is updated accordingly (prefer targeting the block name for experiments; the inner step name should remain stable as `"draft"`)Update docs/examples if they show the old path format.Pitfall:* Don’t change the block name; experiments likely target stage names.---## Step 6 — Enforce single-source temperatureIn `ChatStep` validation (either in `__post_init__` or in the runner before execution):* If `"temperature" in step.params`: raise ValueError instructing to use `step.temperature` instead.Update runner call params composition accordingly:* `call_params = dict(step.params)`* `call_params["temperature"] = step.temperature` (not setdefault)Add tests:* step with `params={"temperature": 0.1}` raises* normal steps still workPitfall:* Do not silently ignore one of the two sources; that reintroduces “why did this run differ?” confusion.---## Step 7 — Move legacy helpers out of `main.py`Identify any unused legacy functions that:* are not called by canonical code* are confusing or conflict with new semanticsMove to `legacy_main.py` (preferred) or delete.Ensure:* imports still succeed* no name collisions remainAdd a short note in README/docs:* “legacy_main.py contains old experimental code; canonical flow is run_generation() in main.py”Pitfall:* Don’t break imports for tests that import `main.py`. Keep the canonical entry stable.---# Testing requirements (pytest)All tests must run offline and must not call real external binaries or network APIs.Add/adjust tests:## Unit tests1. `test_parse_bool_accepts_valid_values`2. `test_parse_bool_rejects_invalid_values`3. `test_step_temperature_conflict_raises`4. `test_invalid_caption_font_path_raises_or_warns` (depending on chosen behavior)5. Optional: `test_logs_contain_full_pipeline_path` (caplog)## Integration test* Update the upscaling integration test to:  * create a platform-appropriate fake binary  * ensure it writes an output image  * ensure your wrapper detects success---# Documentation updates (must do)Update docs (README or docs/pipeline.md):1. Config booleans* explicitly say enabled flags must be boolean / true/false (and what string forms are accepted if any)2. Step parameters* clearly state: **temperature must be set via the `temperature` field**, not inside params3. Transcript paths* update example paths to show `.../<stage>/draft` rather than duplicate stage names4. Caption font config behavior* document what happens when a font path is invalid (raise or warn + fallback)---# Acceptance criteria (Definition of Done)* `enabled: "false"` in config does not enable features; invalid enabled values raise with a clear key path.* Upscaling integration test passes on both POSIX and Windows (or is explicitly skipped only where intended, with justification).* Logs at INFO level show full nested step paths.* Invalid explicit caption font path does not silently fall back.* Transcript paths are clearer (no `.../stage/stage` duplication).* Temperature cannot be specified in two places; conflict raises.* Canonical main module is not cluttered by unused legacy helpers; legacy code is clearly separated.* Full pytest suite passes offline.---# Notes / pitfalls to explicitly avoid* Don’t introduce selector lambdas (`where=lambda ...`) into the user-facing pipeline definition as part of this task.* Don’t “fix” things by adding silent defaults. If you must default, warn loudly and document it.* Don’t make Windows-only assumptions in tests (file extensions, executability, path quoting).* Don’t weaken the Step/Block merge invariant: parent conversation should only change via merge logic.If you want to keep this extremely incremental, implement FR1–FR4 first (config bools, upscaling test portability, full-path logging, font behavior). Then do FR5–FR7 in a second PR (path cleanup, temp enforcement, legacy separation).










































































































































































































































































































































































































































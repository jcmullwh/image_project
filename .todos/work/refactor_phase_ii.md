PROJECT_SPEC — Stage modularization, navigable StageRefs, reusable block patterns, stage-owned config namespaces, and explicit stage IOTaskRefactor the image pipeline stage system to improve navigability, modularity, and extensibility by:1. Replacing stringly-typed stage usage in code with StageRef objects (while keeping string IDs at the config boundary).2. Splitting the “giant stages/prompts file” into one stage per module with clear stage composition.3. Introducing a small set of reusable algorithmic block builders (fanout/reduce, generate/select, iterate) so ToT is not the only special block builder.4. Replacing monolithic stage-option validation with stage-owned config namespaces (typed getters + consumed-keys enforcement).5. Standardizing each stage/block’s input/output contract (requires/provides/captures) and validating composition early.This spec assumes the canonical entry point remains main.py:run_generation() building a root Block(name="pipeline", ...) and executing via ChatRunner.---GoalDeveloper-visible outcomesIDE navigation works: plan → stage symbol → stage module → builder → prompts.Stages are genuinely “standalone compositions of blocks/steps”:each stage lives in its own module,has explicit IO contract,has local config parsing and validation.Algorithmic patterns (fanout/reduce, generate/select, iterate) are reusable and consistent across:ToT refinement,judge ensembles,blackbox refinement iterations,future “unpredictable” integrations (OCR/scoring/toolcalls) without rewriting central framework code.User-visible / run-visible outcomesThe transcript clearly shows:stage boundary blocks,nested algorithmic structure inside stages,explicit refinement stages,stage kind vs stage instance (when custom names are used),stage IO contracts and resolved stage config (high-level summary).Configuration becomes less bureaucratic:core config stays strict,stage options are validated by the stage that consumes them,typos in stage configs fail loudly.---ContextWhat exists nowfoundation/pipeline.py (generic) provides ChatStep, ActionStep, Block, ChatRunner, transcript capture machinery.Stages are already represented as top-level blocks in the pipeline (stage = Block.name boundary).A StageCatalog/registry exists to map stage IDs (strings) to builders.Stage implementations and prompt text are largely colocated in one or a few large files (hard to navigate, hard to reason about modularity).ToT enclave exists as an algorithmic block builder, but it is effectively the only “special” reusable builder.Config validation is centralized and large; changing stage-level knobs tends to require touching shared validation code.Why this is insufficientUsing strings in code (plans referencing "standard.initial_prompt") harms navigation and refactoring.A large consolidated stage/prompt file hides intent: “stages are modular” is not reflected in file structure.Boundary confusion (foundation/framework/implementation) encourages accidental coupling.Central config validation does not scale to unpredictable experiments (OCR, toolcalls, post-image loops).---ConstraintsNo silent fallbacks: missing/invalid stage refs, unknown config keys, ambiguous stage selectors must fail clearly.Offline testability: tests must run without network; fake LLM/image backends.Determinism when randomness is used: seed recorded in transcript; stage-local random choices derived from recorded seed.Transcript is canonical: unique step paths; sufficient metadata to debug without reading source.Cross-platform behavior: no new OS-specific requirements.---Non-goalsNot implementing OCR/post-image analysis loops in this change (architecture should support it, but no new pipeline phases are added here).Not changing image generation/upscaling/upload logic.Not moving foundation/ out of this repo yet (but changes must keep it extraction-ready).Not fully solving experimentation runner proliferation in this change (but design must not preclude unification).---Functional requirementsFR1 — StageRef objects replace raw strings in code1. Introduce a StageRef (or StageDef) object representing a stage kind:id: str (config-facing stable ID)doc/source/tags/kindio: StageIO (requires/provides/captures)build(inputs, *, instance_id, cfg_ns) -> Block2. Plans must refer to stages via imported StageRefs (symbols), not raw strings.3. Config may still refer to stages by string ID, resolved via registry.FR2 — Registry remains as config boundary1. Keep a StageRegistry (formerly StageCatalog) but restrict its role:mapping stage_kind_id -> StageRefdiscovery/listing/docs generationresolving config sequences (strings) to StageRefs2. Registry must fail on:duplicate stage kind IDs,unknown stage kind IDs (with “available stages” listing),ambiguous suffix selection (list matches).FR3 — Stage modules: one stage per file, clear grouping1. Split stage implementations into a stages/ package by domain grouping:stages/preprompt/, stages/standard/, stages/refine/, stages/postprompt/, stages/blackbox/, etc.2. Each stage module must export exactly one primary STAGE: StageRef.3. Prompts:stage-specific prompts live in the stage module (or sibling prompts.py in that group),shared prompts live in prompts/common.py only when used by multiple groups.FR4 — Algorithmic block builders: small reusable set (no ToT one-off)Introduce reusable “patterns” for algorithmic composition expressed purely in Block/Step:1. fanout_then_reduce(...)N isolated ChatSteps in parallel (merge="none"),then a reducer ChatStep that synthesizes their outputs,configurable naming/capture conventions.2. generate_k_then_select(...)generate K candidates in isolation,optionally score/judge (LLM or Action),select output deterministically (seed-based tie-breaking if needed),emit selected text as the stage output.3. iterate_n(...)repeat a block pattern N times with stable unique paths and deterministic iteration indexing,supports blackbox refinement iteration.Requirements:Patterns must create unique transcript paths (no collisions).Patterns must not hard-code image-specific prompt content.Patterns must accept injected prompt builders/callbacks for prompt text.FR5 — ToT enclave becomes “a configuration of patterns”1. Move ToT enclave logic out of “special one-off builder” into:either framework/blocks/patterns.py or framework/blocks/fanout_reduce.py,implemented using fanout_then_reduce(...).2. refine.tot_enclave stage:remains a stage in stages/refine/tot_enclave.py,supplies critic prompts + reducer prompt (implementation-level),uses the generic fanout/reduce pattern (framework-level).3. Judges and blackbox scoring should also be able to use these same patterns (not necessarily in this PR for every stage, but the pattern API must support them).FR6 — Stage-owned config namespaces with strict unknown-key enforcement1. Add stage config namespaces under prompt.stage_configs with a two-level explicit structure:prompt.stage_configs.defaults[stage_kind_id] = {...}prompt.stage_configs.instances[stage_instance_id] = {...}2. For each stage instance:effective config = deep-merge(defaults[kind], instances[instance_id])3. Each stage builder receives a ConfigNamespace wrapper for its effective config.4. ConfigNamespace must:provide typed getters (get_bool/get_int/get_str/get_list_str/get_dict),record consumed keys,raise if any keys remain unconsumed at the end of stage build.5. Global validation rules:Any defaults entry for unknown stage kind IDs → error.Any instances entry for unknown stage instance IDs (not present in resolved stages) → error.Any unconsumed keys inside a stage namespace → error (no silent typos).FR7 — Standardize stage IO contracts and validate composition1. Define StageIO with fields:requires_outputs: set[str]provides_outputs: set[str]captures: set[str] (capture keys written by steps inside the stage)2. Each StageRef declares io.3. Pipeline build must perform a static validation pass:maintain available_outputs starting from {} plus known baseline keys (e.g., seed/profile keys if applicable),for each stage in order:if requires_outputs - available_outputs non-empty → error listing missing requirements,then add provides_outputs and captures.4. Capture key collision validation:if two stages declare the same capture key, error unless explicitly allowed by config (no silent overwrite).5. Record stage IO contracts in transcript summary:outputs.prompt_pipeline.stage_io[stage_instance_id] = {requires, provides, captures}FR8 — Stage kind vs instance must be observable1. When a stage instance name differs from its kind ID, stage block meta must include:meta["stage_kind"] = <kind_id>meta["stage_instance"] = <instance_id>2. Transcript pipeline summary must include a mapping:outputs.prompt_pipeline.stage_instances = [{"instance": ..., "kind": ...}, ...]FR9 — Capture stage correctness: must be stage-boundary producing(Prevents silent wrong capture when selecting composite stages like blackbox iterations.)1. Capture stage must be validated as “producing stage-boundary assistant output”:not merely “contains a ChatStep somewhere”2. If a stage is selected as capture stage but cannot structurally produce a new assistant message at the stage boundary (e.g., all chats isolated via merge="none"), raise with a clear error.3. Default capture stage selection:last producing stage in resolved order,error if none exist.---Proposed conversation flow (most important section)A) Plan code: stages referenced as objects (navigable)from image_project.stages.standard.initial_prompt import STAGE as INITIAL_PROMPTfrom image_project.stages.standard.image_prompt_creation import STAGE as CREATE_PROMPTfrom image_project.stages.refine.tot_enclave import STAGE as REFINE_TOTfrom image_project.stages.postprompt.openai_format import STAGE as OPENAI_FORMATstage_instances = [  INITIAL_PROMPT.instance("standard.initial_prompt"),  CREATE_PROMPT.instance("standard.image_prompt_creation"),  REFINE_TOT.instance("refine.tot_enclave_01"),  OPENAI_FORMAT.instance("postprompt.openai_format"),]B) Pipeline assembly: stage = top-level Blockpipeline_root = Block(name="pipeline", merge="all_messages", nodes=[  stage.build(inputs=plan_inputs, instance_id=stage.instance_id, cfg_ns=stage_cfg_ns(stage))  for stage in stage_instances])runner.run(ctx, pipeline_root)C) ToT refinement stage uses fanout/reduce patternBlock(name="refine.tot_enclave_01", merge="last_response", meta={"stage_kind":"refine.tot_enclave"}, nodes=[  fanout_then_reduce(    name="tot_enclave",    fanout_steps=[      ChatStep(name="critic_hemingway", merge="none", capture_key="enclave.refine.tot_enclave_01.hemingway", ...),      ChatStep(name="critic_octavia", merge="none", capture_key="enclave.refine.tot_enclave_01.octavia", ...),      ...    ],    reduce_step=ChatStep(name="final_consensus", merge="last_response", ...),  )])D) Blackbox iteration stage uses iterate + generate/select patternsTop-level stages remain few and explicit:blackbox_refine.init_stateblackbox_refine.iter_01blackbox_refine.iter_02...blackbox_refine.finalizeInside blackbox_refine.iter_01:nested generate_k_then_select(...)nested judge fanout via fanout_then_reduce(...) if neededTranscript remains rich through nested paths, without stage explosion.---Implementation plan1) Add StageRef/StageIO/StageRegistry primitivesFiles:image_project/framework/stages.py (new)StageIO dataclassStageRef class / dataclassStageInstance (optional small wrapper: kind + instance_id)StageRegistry with:register(StageRef)get(kind_id)list()suffix resolution helpers2) Add ConfigNamespace with consumption trackingFiles:image_project/framework/config_namespace.py (new)ConfigNamespace(stage_id, data)typed getters + constraintsconsume(key)raise_on_unknown_keys()Update config parsing:framework/config.py or run_config.py:parse prompt.stage_configs.defaults and prompt.stage_configs.instancesvalidate dict types (no silent coercion)store raw dicts (core config remains strict)3) Add reusable algorithmic block builders (“patterns”)Files:image_project/framework/blocks/patterns.py (new)fanout_then_reduce(...)generate_k_then_select(...)iterate_n(...) Design constraints:Only uses Block/ChatStep/ActionStep (foundation primitives)No image-specific prompt stringsNaming/capture conventions configurable and deterministic4) Restructure stages into modulesFiles:Create image_project/stages/ package with subpackages per group.For each stage currently defined in the giant file:create stages/<group>/<stage>.pyexport STAGE: StageRefkeep stage-specific prompt content local unless sharedCreate image_project/stages/registry.py (new)imports all STAGEs and registers them into the global StageRegistryserves as the “single import” for tool/docs generation5) Update plans to use StageRefs instead of stringsFiles:image_project/impl/current/plans.py (or split into plans/) Changes:plans import STAGE objectsreturn list[StageInstance] (kind + instance_id)custom plan parsing:strings map to kind_id (instance_id defaults to kind_id)mappings {stage: kind_id, name: instance_id} supported6) Update pipeline construction to use StageInstance → BlockFiles:image_project/app/generate.py (and/or main.py depending on current layout) Changes:resolve stages:build list of StageInstancesfor each stage:resolve stage kind via registrycompute effective config (defaults+instance override)build stage blockapply include/exclude and overrides at stage instance ID levelvalidate stage IO and capture key collisions before running7) Convert ToT enclave to pattern-based implementationFiles:stages/refine/tot_enclave.pyframework/blocks/patterns.py Changes:stage supplies critic prompts and reducer promptuses fanout_then_reduce patternToT no longer stands alone as the only reusable builder8) Update docs generation and stage listingFiles:tols/geatestges_oc.y Chagessource of truthbecoes StgReiry.list(include I ontract fieds in doc)Tests ofle, yte)Fles:tests/updates  newtets (se Testig rirements)-Ero handlig + observabiliy cntractNew/hnged alure ons and behavor. Unkown stg kid inconfgseuence → rse withavalale kinds listed.2.Dupate staeinstnce IDs →ise before pielie uil.. stage_config.efults ontain nkow kin I →raise.4.stage_nis.nsanc ontans instanceIDsnot in reolvetaes →ris.. Stageconfg tans unnown keys (unonsmed) → raise with:sag insance itage id idnknw keyskno/consud keyslst6 StageIO sing requiremetsacopostion tie  ielisting msin otut andhe tage requiring thm.7.Catrestg ivalidotrducg bonday upu)  ris wth stage nstnce  an strucural reason.8. aptre ey olisin→ raise lising both stgenstacesan atu keyTrnsciptlog eecationsoutpuprmp_pipeine.stge_nstance: lt o{isne,knd}outptromptpipelie.stge_i: -stage  contacopsompt_pipelie.sage_configsresolved_suary (ptina): reordhich efulsinstnce verideswee plied (no ful pomptext)Staeblokmeta incuds tge_kid/stag_insce,tas, dc--Dat/arifact changeTrancrt JSON:Adds ouputspromptpipele.sta_ntanceAds otputs.pmp_pplie.stage_iMayadd ott.romt_ppelin.stag_confgs_ummary opional)No hangesto:genertis CSVschemtitlesmnifet schemaimae rtiact nminBackardsomatibilit:ransript consumer must olate nw felds.oremva reqiredi thchane.--Testng requments (ptest, offline)Unit tts1. CnfiNamaceypigget_boo reject"flse"trig unles explicitly lowed defaul: rject).gt_int eectloats/strings.constraints (min/mx/choices) nforced.2 Unnwn ey enfrcemnstage config icludes typokey→ uid ails with cle mesge.Stage conig aplicabiiydfauts with kown kn→ erorinstnce onfg for issig stage isne → erro4.tage IOvalidatinstage reuirs oup not rovide by erlier sag →fas befoe runer xectes5. Capture stge tctral valiatiatempt  etcapture stae to  composit age thatains ly iolaed ChatSteps → ror prevents silent ronapureItegraton tesRu rn_enertio() thfake TexAI/Ime ndassrt:trancrip existsd parsestage oudary blocs ppar n tracrt pahsToT refeenstage onainanot + redu seps ndr ese blokste id/instace apig recorddcapue outpt presen at cxutpts["ime_prompt]--cmentionuptesdos/pipelinemd:plainStageef v ci stag IDsexpan tag Icotracta stge-owned onfislist new promt.stge_cnigsdefaltsnstacs strctureocs/tges.md (generated):icludestage IO requre/rovies/aptursdcs/xperimetsmdhoww toatch stae cofig pr kind vs per instce--Aceptae critiaPlanscotain n w stage IDstrings excet whre parsing a onfig sequene.2.Stags liveas eparate mos ude sags/,each xportigaSTGE: tagRef.3 TT enclaveis ipmeted via neic paten(s;fraeworkconaiatleas te saredpaterns (faoutree, enerate/select, iterate)4.tae nfgs are stae-owned wit:typed etteruownkey nforcemntexiit dfaulsvs per-instanceoveride5 Stage IO contractseist and are aidte pror t executin.6.Slctingan inva catur sag filslodl (n silet ature f pevos-tage otpt).7. Al tes ss ofline.--Pitalls toaoid (repspecific)Usin bol(vlue) anyherfo onfig aring(e.g. bol("alse")).Leting unnad stages slently become sta1, stage_2 (mustror.Treain “cntains ChaSte” as “cptre-tae valid”mustvaldate stage-oundaryodcton)Closurelate-biding bs n lop-buil seps (ind lop vas afly)tage onfgfalbak bior tht hideistakes (eults s instancs must be expicit; unkon key mus eror).Reinroducing end “pipelne R” atraction laer; atterns must coiledirectlyto locks/Stps.



































































































































































































































































































































































































































































































































































































































































































































































































































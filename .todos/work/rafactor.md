# PROJECT_SPEC — Collapse abstractions, make refinement explicit, and simplify stage composition

## Task

Refactor the prompt pipeline architecture so that:

* **Blocks remain the only generic execution primitive** (fully reusable outside this repo).
* **Stages become explicit, image-pipeline-specific “macros”** that compile directly to `Block/ChatStep/ActionStep`.
* **Refinement is an explicit stage** (not a hidden policy wrapper).
* The **blackbox refinement loop becomes readable composition** (nested blocks, clear stage boundaries), not a stage-explosion IR.

---

## Goal

### User-visible / run-visible outcomes

* The transcript’s `prompt_pipeline.resolved_stages` and step `path`s should clearly show **exactly what ran**, including refinement stages.
* The “what runs” structure should be readable from the plan flow without decoding:

  * a refinement policy registry,
  * wrapper stages,
  * or a generated forest of per-candidate/per-judge stage specs.

### Developer-visible outcomes

* Remove “abstraction-on-abstraction”:

  * **No refinement-policy layer**.
  * **No StageSpec→Block compiler layer** for ordinary stages.
* Make it easier to add experiments by composing explicit stages and blocks:

  * “Want ToT refinement twice?” → list two refinement stages with two IDs.
  * “Want 6 blackbox iterations?” → list 6 iteration stage blocks (generated by a simple loop in plan code, not via a stage-IR explosion).

---

## Context (what exists now, why it’s insufficient)

### Current state (simplified)

* `foundation/pipeline.py` provides generic `ChatStep`, `ActionStep`, `Block`, `ChatRunner`.
* `framework/prompt_pipeline/__init__.py` introduces a second abstraction layer:

  * `StageSpec` / `ActionStageSpec`
  * `resolve_stage_specs(...)`
  * `build_pipeline_block(...)` which **wraps each stage** based on a global/per-stage refinement policy.
* `framework/refinement.py` defines refinement policy objects (e.g., ToT enclave) that inject extra steps *inside* a stage.
* `framework/blackbox_refine_loop.py` generates a long list of “stages” (candidate gen stages + judge stages + select stages) → stage explosion.

### Why this is a problem

* Too many “primitives”:

  * Steps/Blocks (good)
  * StageSpec (IR)
  * Refinement policy wrappers (cross-cutting)
  * Plans + plugins + overrides (more cross-cutting)
* Refinement behavior is **not visible** in the flow. You can’t tell what runs by reading the stage list alone.
* The blackbox refine loop’s stage list becomes an **implementation detail leak**, not a readable architecture.

---

## Constraints

* **No silent fallbacks**: invalid stages, duplicate IDs, invalid config types, missing outputs must error loudly.
* **Offline tests only**: Fake TextAI/ImageAI; no network calls.
* **Determinism**: any randomness affecting prompts must be seeded and recorded.
* **Transcript is canonical**: must remain high-quality; paths must remain unambiguous and stable.
* **Cross-platform**: no new platform-specific requirements.

---

## Non-goals

* Not rewriting prompt *content* (wording/templates), except where necessary to decouple “draft vs refine” execution.
* Not changing image generation, upscaling, rclone behavior.
* Not moving `foundation/pipeline.py` to another repo in this refactor (just keep it clean and generic).

---

## Functional requirements

### FR1 — “Stage” becomes an explicit Block boundary

1. A **stage** is defined as a **top-level `Block` directly under the root pipeline block**.
2. A stage must have:

   * a unique `Block.name` (stage ID),
   * a merge mode (`last_response` or `none` typically),
   * optional stage-level `meta` (`doc/source/tags`).
3. Stages may contain **nested blocks** and multiple steps.

### FR2 — Remove implicit refinement policy (make refinement explicit)

1. Remove `prompt.refinement.policy` from config and `RunConfig`.
2. Remove per-stage `refinement_policy` override and all policy registry logic.
3. Add explicit refinement stages (stage catalog entries), starting with:

   * `refine.tot_enclave`: runs the ToT enclave critique+consensus refinement on the **current conversation last assistant output**.
4. Refinement must appear explicitly in:

   * `prompt_pipeline.resolved_stages`,
   * transcript step paths (e.g., `pipeline/refine.tot_enclave/tot_enclave/final_consensus`).

### FR3 — Capture semantics become simple and compositional

1. **Intermediate outputs** are captured via **Step-level `capture_key`**:

   * Chat output: `ChatStep.capture_key`
   * Action output: `ActionStep.capture_key`
2. The **final image prompt** is captured by setting **`capture_key="image_prompt"` on the chosen capture stage Block**, not by overloading stage output keys.
3. It must be possible for a stage to:

   * capture an intermediate output (e.g., `postprompt.nudged_prompt`) via a step capture key,
   * while also being (or not being) the final capture stage without conflicts.
4. If capture stage produces no assistant output, fail fast with a clear error:

   * “capture_stage must be a chat-producing stage; got action-only stage …”

### FR4 — Stage modifiers still work, but only on stage IDs

1. Keep support for:

   * `prompt.stages.include`
   * `prompt.stages.exclude`
   * `prompt.stages.overrides` (temperature + params only)
   * `prompt.output.capture_stage`
2. Stage selection uses stage IDs (Block names). Suffix matching remains (same rules as now):

   * if selector has no dot, match uniquely by `.suffix`.
   * if ambiguous → error listing matches.
3. Overrides apply only to a stage’s **primary draft chat step**:

   * convention: the primary step is `ChatStep(name="draft", meta={"role": "primary"})`
4. If an override targets a stage that does not have a primary draft step, fail fast:

   * e.g., `refine.tot_enclave` or blackbox iteration composite stages.

### FR5 — Custom plan sequences must support repeated stage kinds

To keep composition explicit without forcing you to create N nearly-identical stage catalog entries:

1. Allow `prompt.stages.sequence` entries to be either:

   * **string**: `"standard.initial_prompt"` (kind and instance are the same)
   * **mapping**:

     ```yaml
     - stage: refine.tot_enclave
       name: refine.tot_enclave_01
     ```
2. `stage` is the catalog key; `name` becomes the **actual stage ID** (Block.name).
3. Validate:

   * `stage` exists in StageCatalog,
   * `name` is unique across the sequence.

### FR6 — Blackbox refinement loop becomes “few stages, nested structure”

1. Replace `build_blackbox_refine_loop_specs(...) -> list[StageNodeSpec]` with:

   * `build_blackbox_refine_loop_blocks(...) -> list[Block]` (or similar)
2. Represent the loop as:

   * `blackbox_refine.init_state` (action stage block)
   * `blackbox_refine.iter_01`, `blackbox_refine.iter_02`, … (composite stage blocks)
   * `blackbox_refine.finalize` (action stage block)
3. Inside each `blackbox_refine.iter_XX` stage block:

   * nested blocks for beams (if beam algorithm),
   * nested steps for candidate generation,
   * nested steps for judge scoring,
   * a final action step selecting updated beams/state.
4. All internal steps must have unique paths and capture keys, e.g.:

   * `bbref.iter_01.beam_01.cand_A.prompt`
   * `bbref.iter_01.judge.j1.scores`
5. Determinism requirements:

   * mutation directive selection remains deterministic (hash-based or seeded), and directive chosen is recorded in outputs/transcript.
6. This must reduce “stage explosion” in `prompt_pipeline.resolved_stages` while keeping **full audit trail** inside the transcript.

### FR7 — Prompt pipeline metadata remains strong

Update `ctx.outputs["prompt_pipeline"]` to include:

* `requested_plan`
* `plan`
* `resolved_stages` (stage IDs)
* `capture_stage`
* `stages_include`, `stages_exclude`
* `stage_overrides` (as before, minus refinement fields)
* context fields as before

Remove:

* `refinement_policy`

Optionally add:

* `refinement_mode: "explicit_stages"`

### FR8 — No new silent failure modes

1. Duplicate stage IDs → error at plan resolution time.
2. Unknown stage in custom sequence → error with suggestions (keep current behavior).
3. Duplicate capture keys across steps/stages should fail as today (and ideally fail earlier; see Implementation Plan).

---

## Proposed conversation flow

This section shows the **actual Block/Step shapes** we will construct.

### A) Standard plan (example: refine only at the end, explicit)

```python
pipeline = Block(name="pipeline", merge="all_messages", nodes=[
  Block(name="preprompt.select_concepts", merge="none", nodes=[
    ActionStep(name="action", fn=select_concepts)
  ]),

  Block(name="preprompt.filter_concepts", merge="none", nodes=[
    ActionStep(name="action", fn=filter_concepts)
  ]),

  Block(name="standard.initial_prompt", merge="last_response", nodes=[
    ChatStep(name="draft", prompt=..., temperature=..., params=..., meta={"role":"primary"})
  ]),

  Block(name="standard.section_2_choice", merge="last_response", nodes=[
    ChatStep(name="draft", prompt=..., temperature=..., params=..., meta={"role":"primary"})
  ]),

  Block(name="standard.section_2b_title_and_story", merge="last_response", nodes=[
    ChatStep(name="draft", prompt=..., temperature=..., params=..., meta={"role":"primary"})
  ]),

  Block(name="standard.section_3_message_focus", merge="last_response", nodes=[
    ChatStep(name="draft", prompt=..., temperature=..., params=..., meta={"role":"primary"})
  ]),

  Block(name="standard.section_4_concise_description", merge="last_response", nodes=[
    ChatStep(name="draft", prompt=..., temperature=..., params=..., meta={"role":"primary"})
  ]),

  Block(name="standard.image_prompt_creation", merge="last_response", nodes=[
    ChatStep(name="draft", prompt=..., temperature=..., params=..., meta={"role":"primary"})
  ]),

  Block(name="refine.tot_enclave", merge="last_response", nodes=[
    Block(name="tot_enclave", merge="all_messages", nodes=[
      ChatStep(name="hemingway", merge="none", capture_key="enclave.refine.tot_enclave.hemingway", ...),
      ChatStep(name="octavia", merge="none", capture_key="enclave.refine.tot_enclave.octavia", ...),
      ...
      ChatStep(name="final_consensus", ...),
    ])
  ]),

  Block(name="postprompt.openai_format", merge="last_response", nodes=[
    ChatStep(name="draft", prompt=..., temperature=..., params=..., meta={"role":"primary"})
  ]),
])
# capture_key="image_prompt" is set on "postprompt.openai_format"
```

Key clarity improvements:

* Refinement appears as its own stage (`refine.tot_enclave`) and the ToT threads live under it.
* No “policy” deciding hidden behavior at build time.

### B) Custom plan with repeated refinement stages (YAML)

```yaml
prompt:
  plan: custom
  stages:
    sequence:
      - preprompt.select_concepts
      - standard.initial_prompt
      - stage: refine.tot_enclave
        name: refine.tot_enclave_01
      - standard.image_prompt_creation
      - stage: refine.tot_enclave
        name: refine.tot_enclave_02
      - postprompt.openai_format
```

### C) Blackbox refine plan (few stage IDs, nested internals)

Stage list (top-level):

* `preprompt.select_concepts`
* `preprompt.filter_concepts`
* `blackbox_refine.seed_prompt` (explicit stage; replaces plan plugin mutation of another stage)
* `blackbox_refine.init_state`
* `blackbox_refine.iter_01`
* `blackbox_refine.iter_02`
* …
* `blackbox_refine.finalize`
* `postprompt.profile_nudge`
* `postprompt.openai_format` (capture)

Inside `blackbox_refine.iter_01` the transcript paths show the detail:

* `pipeline/blackbox_refine.iter_01/beam_01/cand_A`
* `pipeline/blackbox_refine.iter_01/judge/j1`
* `pipeline/blackbox_refine.iter_01/select`

---

## Implementation plan

### 1) Introduce a “stage is block” helper API

Create helpers in `image_project/framework/prompt_pipeline/__init__.py` (or a new `framework/stages.py` if you prefer, but keep imports stable):

* `make_chat_stage_block(...) -> Block`
* `make_action_stage_block(...) -> Block`

Conventions:

* Primary chat step is always named `draft` and includes `meta={"role": "primary"}`.
* Stage-level metadata gets stored on `Block.meta`:

  * `doc`, `source`, `tags`.

### 2) Refactor StageCatalog to build Blocks, not StageSpecs

Modify `image_project/impl/current/prompting.py`:

* Replace `StageSpec`/`ActionStageSpec` types with returning `Block`.
* Update `StageCatalog.register(...)`:

  * optionally accept `kind="chat"|"action"|"composite"` for docs.
* Update `StageCatalog.build(...)` signature to support instance naming:

  * `build(stage: str, inputs: PlanInputs, *, name: str | None = None) -> Block`
* Validation:

  * builder must return a Block with `.name == (name or resolved_stage_id)`

### 3) Convert every stage definition to the new block form

In `image_project/impl/current/prompting.py`:

* Each former `StageSpec(...)` becomes `make_chat_stage_block(...)`.
* Each former `ActionStageSpec(...)` becomes `make_action_stage_block(...)`.
* Any former `output_key` becomes a `capture_key` on the `draft` ChatStep (or action step), not on the stage block.

Example conversion:

* Before:

  * stage had `output_key="idea_cards_json"`
* After:

  * `ChatStep(..., capture_key="idea_cards_json")`

### 4) Add `refine.tot_enclave` stage

* Implement as a StageCatalog entry returning a block:

  * `Block(name=stage_id, merge="last_response", nodes=[make_tot_enclave_block(stage_id, ...)])`
* Keep `make_tot_enclave_block(...)` from `framework/refinement.py`, but delete the **policy classes/registry** (see step 6).

### 5) Rewrite stage resolution + pipeline build (remove StageSpec IR)

Refactor `image_project/framework/prompt_pipeline/__init__.py`:

* Delete:

  * `StageSpec`, `ActionStageSpec`, `StageNodeSpec`
  * `RefinementPolicy` integration points
  * `build_pipeline_block(...)` (StageSpec compiler)
* Replace with:

  * `ResolvedStages` storing:

    * `stages: tuple[Block, ...]`
    * `stage_ids: tuple[str, ...]`
    * `capture_stage: str`
    * `metadata: dict[str, Any]`
  * `resolve_stage_blocks(stage_blocks, include, exclude, overrides, capture_stage)`

Override application:

* Find the stage block with matching name.
* Apply override only to the primary step:

  * `ChatStep(name="draft", meta.role=="primary")`
* If not found → error “override target stage has no primary draft step”.

Capture selection:

* If config `prompt.output.capture_stage` is set → resolve it.
* Else default capture stage = **last chat-producing stage** in the resolved list.
* Apply capture by cloning that stage block with `capture_key="image_prompt"` at the block level.
* Validate capture eligibility by scanning for at least one `ChatStep` in that stage (recursive).

### 6) Remove refinement policy config + code

* `framework/config.py`:

  * remove parsing of `prompt.refinement.policy`
  * remove `RunConfig.prompt_refinement_policy`
* `framework/refinement.py`:

  * keep only block-building helpers (e.g., `make_tot_enclave_block` + prompt functions)
  * remove:

    * policy classes
    * registry

### 7) Update plans to compose explicit refinement stages

In `image_project/impl/current/plans.py`:

* `SequencePromptPlan.stage_specs()` becomes `stage_blocks()` returning `list[Block]`.
* Update plan flows to include `refine.tot_enclave` explicitly where desired.

  * Recommend: **refine only the final prompt** (keeps mental load low).
* Remove plan plugin hacks that mutate stage specs (e.g., blackbox_refine seed-stage plugin), replacing them with explicit stages (see step 8).

### 8) Refactor blackbox refine loop into nested blocks

In `framework/blackbox_refine_loop.py`:

* Replace `build_blackbox_refine_loop_specs` with `build_blackbox_refine_loop_blocks`.
* Each iteration becomes a composite stage block:

  * `Block(name=f"blackbox_refine.iter_{i:02d}", merge="none", nodes=[...])`
* Candidate generation / judge scoring / selection become steps inside nested blocks.

Also:

* Add an explicit stage `blackbox_refine.seed_prompt` (chat stage):

  * runs the seed prompt generation
  * captures to `bbref.seed_prompt`
  * merge="none"

### 9) Update `app/generate.py` integration

* Replace:

  * `stage_specs = plan.stage_specs(inputs)`
  * `resolve_stage_specs(...)`
  * `plan.execute(..., resolved_stages, ...)`
* With:

  * `stage_blocks = plan.stage_blocks(inputs)`
  * `resolved = resolve_stage_blocks(...)`
  * `runner.run(ctx, pipeline_root_block)`

Update prompt pipeline metadata:

* remove `refinement_policy`
* add maybe `refinement_mode: "explicit_stages"`

Update log line accordingly.

### 10) Update stage docs generator

`tools/generate_stages_doc.py` currently infers stage kind from return annotations.

* Update it to read explicit `kind=` from `StageCatalog.register(...)` decorator args (recommended), or drop kind column if not needed.

### 11) Tests (pytest, offline)

Update existing tests to reflect:

* no refinement policy field
* explicit refine stage IDs and paths
* new blackbox refine nested structure

Add/modify tests:

1. **Refinement explicitness**

   * standard plan transcript includes `pipeline/refine.tot_enclave/tot_enclave/final_consensus`
   * excluding `refine.tot_enclave` removes those paths
2. **Capture key conflicts removed**

   * choose capture stage that also has an internal step capture key → should not error
3. **Blackbox refine loop structure**

   * resolved stages include `blackbox_refine.iter_01` not dozens of candidate stage IDs
   * transcript contains nested paths for candidates/judges under the iteration stage
4. **Determinism**

   * mutation directive selection stable across runs given same seed

---

## Error handling + observability contract

### New/changed failure points

* Duplicate stage IDs after resolution → raise `ValueError("Duplicate stage id: ...")`
* Custom plan mapping entry missing required keys → raise with exact path:

  * `prompt.stages.sequence[3].stage missing/invalid`
* Override targets stage without primary draft → raise:

  * `prompt.stages.overrides['X'] targets non-overridable stage (no primary draft step)`
* Capture stage is action-only/non-chat → raise:

  * `capture_stage='X' must be chat-producing stage; no ChatStep found`

### Transcript/log expectations

* Transcript `steps[].path` must include nested structure for composite stages.
* `outputs.prompt_pipeline` must contain:

  * resolved stage IDs (top-level only)
  * capture stage ID
  * include/exclude/overrides snapshot

---

## Data/artifact changes

### Transcript JSON

* `outputs.prompt_pipeline.refinement_policy` removed.
* `resolved_stages` may change (explicit refinement stages added).
* Step paths change:

  * ToT enclave steps move from `pipeline/<stage>/tot_enclave/...`
  * to `pipeline/refine.tot_enclave/tot_enclave/...` (or named instances)

### CSV schemas / titles manifest

* No change.

---

## Documentation updates

* `docs/pipeline.md`:

  * remove “refinement policy” discussion
  * show refinement as explicit stage
* `docs/experiments.md`:

  * update examples from `prompt.refinement.policy=...` to including/excluding `refine.tot_enclave`
* `docs/stages.md`:

  * regenerate using updated generator (StageCatalog now returns Blocks)

---

## Acceptance criteria

1. **No refinement policy exists** in config parsing, RunConfig, or pipeline build code.
2. Refinement is visible as a stage:

   * resolved stages include `refine.tot_enclave` (or named instances)
   * transcript shows enclave steps under that stage.
3. Blackbox refine no longer explodes stages:

   * resolved stage IDs list is small (init + iterations + finalize + postprompt)
   * transcript still contains per-candidate and per-judge steps with unique paths.
4. Stage output captures and final capture can coexist:

   * no “capture_stage output_key conflict” class of failure.
5. All tests pass offline.

---

## Pitfalls to avoid (specific to this refactor)

* Accidentally reintroducing hidden behavior via “auto-insert refinement stages” logic.
* Overriding temperatures by accidentally hitting *all* chat steps inside composite stages (must only affect primary draft).
* Duplicate capture keys when repeating stage kinds that capture to fixed keys (validate or fail clearly).
* Silent changes to stage naming that make suffix matching ambiguous (fail on ambiguity, list matches).
